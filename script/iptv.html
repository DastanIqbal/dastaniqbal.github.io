<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Decrypt API Response</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    pre { background: #f4f4f4; padding: 15px; }
    button { padding: 10px 15px; margin-top: 15px; }
    #output {
      white-space: pre-wrap;   /* allows wrapping */
      word-break: break-word;  /* breaks long words */
    }
  </style>
</head>
<body>

<h2>API Decryption Flow</h2>

<button onclick="startProcess()">Fetch, Call, and Decrypt</button>

<h3>Decrypted Response:</h3>
<pre id="output">Waiting...</pre>

<!-- Hidden fields -->
<input type="hidden" id="password" value="yX5t[2N7ndG$;a=P" />
<input type="hidden" id="ciphertext" />

<script>
async function deriveKey(password, salt, algorithm, usages) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
  );

  const derivedAlgo = algorithm === "HMAC"
    ? { name: "HMAC", hash: "SHA-256", length: 256 }
    : { name: "AES-CBC", length: 256 };

  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 10000, hash: "SHA-1" },
    keyMaterial, derivedAlgo, false, usages
  );
}

function parseCiphertext(data) {
  const version = data[0];
  const options = data[1];
  const isEncrypted = (options & 1) === 1;
  let offset = 2;
  let salt = null, passwordVerifier = null;

  if (isEncrypted) {
    salt = data.slice(offset, offset + 8); offset += 8;
    passwordVerifier = data.slice(offset, offset + 8); offset += 8;
  }

  const iv = data.slice(offset, offset + 16); offset += 16;
  const ciphertext = data.slice(offset, data.length - 32);
  const mac = data.slice(data.length - 32);

  return { version, options, isEncrypted, salt, passwordVerifier, iv, ciphertext, mac };
}

function getDataForMac(parsed) {
  const headerLen = 2;
  const extra = parsed.isEncrypted ? (8 + 8) : 0;
  const len = headerLen + extra + 16 + parsed.ciphertext.length;
  const data = new Uint8Array(len);
  let offset = 0;

  data[offset++] = parsed.version;
  data[offset++] = parsed.options;
  if (parsed.isEncrypted) {
    data.set(parsed.salt, offset); offset += 8;
    data.set(parsed.passwordVerifier, offset); offset += 8;
  }
  data.set(parsed.iv, offset); offset += 16;
  data.set(parsed.ciphertext, offset);
  return data;
}

function decodeBase64(str) {
  return Uint8Array.from(atob(str), c => c.charCodeAt(0));
}

function fixBase64(str) {
  return str.replace(/-/g, '+').replace(/_/g, '/').padEnd(str.length + (4 - str.length % 4) % 4, '=');
}

async function decryptBase64Cipher(ciphertextB64, password) {
  const data = decodeBase64(ciphertextB64);
  const parsed = parseCiphertext(data);

  if (!parsed.isEncrypted) throw new Error("Data is not password-encrypted");

  const key = await deriveKey(password, parsed.salt, "AES-CBC", ["decrypt"]);
  const hmacKey = await deriveKey(password, parsed.passwordVerifier, "HMAC", ["sign"]);

  const dataForMac = getDataForMac(parsed);
  const calculatedMac = new Uint8Array(await crypto.subtle.sign("HMAC", hmacKey, dataForMac));

  if (!calculatedMac.every((b, i) => b === parsed.mac[i])) {
    throw new Error("MAC verification failed.");
  }

  const decrypted = await crypto.subtle.decrypt(
    { name: "AES-CBC", iv: parsed.iv },
    key,
    parsed.ciphertext
  );

  return new TextDecoder().decode(decrypted);
}

async function startProcess() {
  const output = document.getElementById("output");
  output.textContent = "Fetching...";

  try {
    const githubRes = await fetch("https://raw.githubusercontent.com/bhhoomas/surfix/refs/heads/main/readme_mkpro");
    const githubJson = await githubRes.json();
    const proxy = "https://corsproxy.io/?url=";
    const hostUrl = proxy + githubJson.host;

    // output.textContent = `Calling API...`;

    // const formData = new URLSearchParams();
    // formData.append("username", "76809211053");
    // formData.append("mac", "02:48:A5:B1:49:44");
    // formData.append("imei", "12345678");
    // formData.append("app", "istar_pro_max");
    // formData.append("deviceinfo", "SM-G996B,samsung,5.4.61-20701476-abG996BXXU1AUAB,30,2404.2,92.99.106.126,192.168.1.15,fe80::84c3:75ff:fe69:9901%dummy0");

    // const apiRes = await fetch(hostUrl, {
      // method: "POST",
      // headers: {
        // "User-Agent": "Dalvik/2.1.0 (Linux; U; Android 11; SM-G996B Build/RP1A.200720.012)",
        // "Content-Type": "application/x-www-form-urlencoded"
      // },
      // body: formData
    // });

    // const text = await apiRes.text();
    // const dataRes = JSON.parse(text);
    // const cipherText = dataRes.data;
    const cipherText = "AwGK7bS1Vm9yNlN0/9K+W3omFpScEFg6RBNvfcwJRnWa3DDKI2yhNKhCdnWcnXsDdmaobPJMQa9G7ESaOIUk5DogoKt5tI/TV3DKqGGJEIUPr50UFdqCzMcRLoCJWoZ+n9AIi3sniGiqHWwWVo118wXGxlq3SdHzCVJtHhg7+BVJsbnHVJrAKh25S3JDoSYW47qzanRSZ3+TnSMYP2yTkDO8CE5PmUdzp8I95GhOM77V4sgF5l+HEp4Gd/8XqerfaGn01QrCbY/165vq/hocUU+2Y2gC3GVsNXiptFtMt5vcNP7Fp7j2X3XOi9u7hmljl4HOswfSSE6lKHOInNbWUP9wDFcToOZfseH5s2dLYOJXHRMvjWKaPc2SAL2f2RAAvcjaxd3VObcEuThdRVhuzk8d2wmkCOLwqSaWkSoRVUaYwYIB17MdqmFNk1uw4R/uwtjiajm85eBa0G6gT/rJ+ageNodP/MgoDbpkOVTVcjjsienGU2jwddrOKzXqrCB603yO2DDAkFprDzpKEzyjou+40NQU4A9jkIFwwgIAdd0NLKyN2Ghfr6THckkcs3UwFfIFm7NqFYtxLNTWOIxR6iFIdc2WQ/1Kldn3wS+gkWpWYrcsQoNvnePPSzU910sFNNBZAjFCZGQRq83I40T27HL4rxGZaxmUgbZORKJf83x7l0tDsEegM6FmmouBNzII6xM1KcSZHesdCMvDsIOYOdlRcatC9YzK6rhaO0YbAgkBemn0sr1k30Na+IEPbAwSM1KrTjcpt69FK4pfSuttokCmgoKJOvZkcMHJEVYFSKvcTeAKIpLM27Hks8TXlDXD4OJyEvqUtJu1Ej0YjoTPDQ1fDlC4GpYc6rJWgnFY44BLiQPA0fPqdPX+S1u7/Cf3ClvRugQzWuoXzd684LaMTyVF0C1/5AnSJyKsDj+e+q7LwVwm74kdtS+QHRysHbduSSpoY35x7wuo9lN++zj1e8HZZoph9isRsEyrBqvAAcZJdh2xEC1fQmLJYxwbznfbtBvuGlzrUmAqXIHXd8UvbyQAVDACxJqRYL5fodyjwUKp3WI9li9wXr6rXrwpTMDgODwdd6vdUnGW6fP0gY9mbraf6gM2P9NV7kNqERdNfgPFHbdvECHkpvwLdRqFGv/aJ83q7vyN88ENKxiPIAW72jzr+EqB9E8aB+UzBjn3QnlnKLmbXFpY5jMbeF5RubIQJDGy3d4RQI73QCtjGM9blQ6lStmMK7s1Z2jExMFJhmZLkxiZgybvqHECxthp+sI8IrCtc9i4htWUF9567o3nDeR8";
    document.getElementById("ciphertext").value = cipherText;

    const password = document.getElementById("password").value;
    output.textContent = "Decrypting response...";

    const decrypted = await decryptBase64Cipher(cipherText, password);
    output.textContent = decrypted;
  } catch (err) {
    output.textContent = "Error: " + err.message;
  }
}
</script>

</body>
</html>
